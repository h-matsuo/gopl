# gopl

ギモン：

```go
var s1 []int    // s1 == nil => true
s2 := []int{}   // s2 == nil => false
```

`s2` は「要素数・容量ともに 0」のスライスを指すが、
これはつまりメモリ上に何も確保していないから `s1` と同じなのでは？と思ったら、
`s2` は `nil` ではなかった。

`s1` と `s2` はどう違うのか？

`s2` が指してるアドレスを取得できる関数ある？
=> `fmt.Printf("%p", &s1)` で取得できるけど、`s1` でも値が存在した。どういうこと？

---

`nil` の拡張ができる：

```go
s := append([]int(nil), 1)
```

---

なぜ、len() や cap() はメソッドとして定義されなかったんだろう？
array.len() とした方が分かりやすい気もするし、
特定の型に対して操作ができる関数はメソッドとして定義した方が IDE の恩恵も受けやすいように思う

---

構造体と、メソッド、そして ~型のコンストラクタ~ 、インターフェース。
これもうほぼクラスでは？（extends や implements はないけど
※型のコンストラクタは構文ではなくイディオムだった
ここまでオブジェクト指向チックな書き方を用意しておいて、
正式にオブジェクト指向なパラダイムにしなかったのは何でなんだろう

--> たぶん、ガチのオブジェクトにしてしまうと、ポリモーフィズムなど実行時のオーバヘッドが大きくなるから？
Go 言語ではあくまでコンパイル時にどのメソッドを実行するか、は決まってる気がする

--> 本当に？インターフェースメソッドとかコンパイル時に決まるのかな

---

x, y := someMethod() の y は省略できませんが（コンパイルエラー）、
value, ok := someMap[""key""] や value, ok := <-someCh の ok は省略できます。なぜでしょうか。

---

この本を終えたあとにオススメの本
